# Specifications
_HW2: MiniJava Type checking_  
_May 11, 2025_  

## Problem Statement
Use `JTB` and `JavaCC` and write in Java one or more visitors that type check a MiniJava program. Follow the `miniJava-typesystem.pdf` for your homework implementation.
Your main file should be called `Typecheck.java`, and if `P.java` contains a program to be type checked, then:
``` bash
java Typecheck < P.java
```
Should print either `"Program type checked successfully"` or `"Type error"`.

**Final Submission Requirements:**  
File Name: `Typecheck.java`  
Output: Exactly one of two messages:  
- `"Program type checked successfully"`  
- `"Type error"`  
Integration: Ensure symbol table and type-checking visitors work with the provided `Main.java` structure.  

## Information

### Type Checking  
The type checker is part of the front end of a compiler that ensures syntax is correct. All the tokens that are seen here are valid, however their placement next to each other could be invalid. This means a typer checker's job is to make sure variables have legal types using legal operations and accessing other types legally.  
**Examples:**  
- Type Mismatch: `string s = 10;`  
- Invalid Operation: `"hello" * 5` _(`*` is not defined for `Strings`)_  
- Scope: Using an outer-scope variable’s type in an inner scope incorrectly.  

### Minijava  
MiniJava is a subset of Java.  The meaning of a MiniJava program is 
given by its meaning as a Java program.  Overloading is not allowed 
in MiniJava. The MiniJava statement System.out.println( ... ); can 
only print integers. The MiniJava expression e.length only applies 
to expressions of type int[].  
_Specifications listed in `MiniJava-typesystem.md`._

### JavaCC
Generates a parser from a grammar file. It tokenizes input and builds a parse tree.

### JTB (Java Tree Builder)
Generates an Abstract Syntax Tree (AST) and visitor classes from the same grammar. This enables structured traversal of the AST.

### Visitors
The visitor design pattern lets you define operations on a data structure like a tree without modifying the classes of the elements being operated on.

### Syntax Tree
A syntax tree is a blueprint of the code’s grammatical structure in a tree form.
- Nodes: Grammar rules (if-statement, expression, function-declaration)
- Leaves: Tokens (literals (5, "hello"), operators (+, *), or keywords (if, return))

### Abstract Syntax Tree
The Abstract Syntax Tree is an abstracted form of the Syntax Tree created by the parser. In this abstracted form it best represents the syntactic structure of the source code.
The AST models the relationship between tokens in the course code, as a tree comprised of nodes and the nodes containing children.

### Tokens
Tokens are the smallest meaningful units in a programming language.
Generated by the Lexer by matching Token type with a Lexeme in the source code.
Tokens appear as: keywords, identifiers, operators of the language.  
**Example:**  
`x = 10 + y`  
Tokens:  
- `[Identifier: x]`
- `[Operator: =]`
- `[Number: 10]`
- `[Operator: +]`
- `[Identifier: y]`

### Symbol Table
Data structure used by compilers to track identifiers (variables, functions, classes, etc.) and their associated properties in a program.  
- Name Resolution: Ensures identifiers are declared before use and resolves references to the correct scope.  
- Type Checking: Validates operations (int + string is invalid)  
- Error Detection: Catches duplicate declarations or undeclared variables  
- Code Generation: Provides memory addresses for variables/parameters  
- Optimization: Helps track variable lifetimes for efficiency  

1. Build Symbol Table: Initial AST traversal will collect all declarations and scopes  
2. Check Types: Validate type rules using the symbol table in another pass

# Solution

## Functionality Needed
The Tokens, and Abstract Syntax Tree is handled, now we need to write code that can walk through the tree and generate a Parse Table. Then using the Parse table we will walk through the tree again to make sure the types and scopes are valid.

## Files to work on
- `Typecheck.java`
- `PPrinter.java`
- `MyType.java`
- `SymTableVis.java`
- `TypeCheckSimp.java`

## Steps

### 1. Setup
Use JTB and JavaCC to generate the parser and AST.
``` bash
unzip javacc-6.0.zip
java -jar jtb132.jar minijava.jj
java -cp javacc-6.0/bin/lib/javacc.jar javacc jtb.out.jj
```
Generate syntax tree classes and understand the AST structure via a pretty-print visitor.

### 2. Build the Symbol Table
Create a visitor (`SymTableVis`) to collect declarations (classes, methods, variables) and their scopes.
- Track class hierarchies, method parameters, and local variables.
- Handle scopes (e.g., class-level vs. method-level variables).
- Store identifiers and their types in a structured symbol table (e.g., `HashMap`).
- Resolve inheritance (MiniJava supports single inheritance).

### 3. Implement Type Checking
Create a bottom-up visitor (`TypeCheckSimp`) to validate types.
**Key Checks:**
- **Variables/Expressions:** Ensure assignments, operations, and method returns have compatible types.
- **Method Calls:** Verify argument types match parameter declarations.
- **Arrays:** Check `e.length` is only applied to `int[]`.
- **Overloading:** Disallow method/constructor overloading.
- **System.out.println:** Ensure it only prints integers.
- **Inheritance:** Validate method overrides match superclass signatures.

### 4. Error Handling
**Requirements:**
- Detect and report type mismatches, undefined variables, invalid method calls, etc.
- Terminate with `"Type error"` if any issue is found.

### 5. Testing & Debugging
**Test Cases:**
- Valid programs (e.g., `Factorial.java`).
- Invalid programs (e.g., assigning a `boolean` to an `int`, calling undefined methods).
**Run Tests:**
``` bash
java Typecheck < P.java
```